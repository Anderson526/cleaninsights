/**
 * Campaign.ts
 * CleanInsightsSDK
 *
 * Created by Benjamin Erhart on 19.01.21.
 * Copyright Â© 2021 Guardian Project. All rights reserved.
 */
export { Campaign, CampaignData };
import dayjs from 'dayjs';
import duration from 'dayjs/plugin/duration';
import { EventAggregationRule } from './EventAggregationRule';
import { Event } from './Event';
interface CampaignData {
    start: string;
    end: string;
    aggregationPeriodLength: number;
    numberOfPeriods?: number;
    onlyRecordOnce?: boolean;
    eventAggregationRule?: string;
    strengthenAnonymity?: boolean;
}
declare class Campaign {
    start: dayjs.Dayjs;
    end: dayjs.Dayjs;
    aggregationPeriodLength: number;
    numberOfPeriods: number;
    onlyRecordOnce: boolean;
    eventAggregationRule: EventAggregationRule;
    strengthenAnonymity: boolean;
    /**
     * @param {dayjs.Dayjs|CampaignData} start
     *      The start of the campaign. (inclusive)
     *
     * @param {dayjs.Dayjs=} end
     *      The end of the campaign. (inclusive) OPTIONAL if provided via an object as first argument.
     *
     * @param {number=} aggregationPeriodLength
     *      The length of the aggregation period in number of days. At the end of a period,
     *      the aggregated data will be sent to the analytics server.
     *      OPTIONAL if provided via an object as first argument.
     *
     * @param {number=} numberOfPeriods=1
     *      The number of periods you want to measure in a row. Therefore the total
     *      length in days you measure one user is `aggregationPeriodLength * numberOfPeriods`
     *      beginning with the first day of the next period after the user consented.
     *
     * @param {boolean=} onlyRecordOnce=false
     *      Will result in recording only the first time a visit or event happened
     *      per period. Useful for yes/no questions.
     *
     * @param {EventAggregationRule=} eventAggregationRule=.Sum
     *      The rule how to aggregate the value of an event (if any given)
     *      with subsequent calls.
     *
     * @param {boolean=} strengthenAnonymity=false
     *      When set to true, measurements only ever start at the next full period.
     *      This ensures, that anonymity guaranties aren't accidentally reduced because the
     *      first period is very short.
     */
    constructor(start: dayjs.Dayjs | CampaignData, end?: dayjs.Dayjs, aggregationPeriodLength?: number, numberOfPeriods?: number, onlyRecordOnce?: boolean, eventAggregationRule?: EventAggregationRule, strengthenAnonymity?: boolean);
    get aggregationPeriod(): duration.Duration;
    /**
     * Returns the current measurement period, aka. the period where NOW is in.
     *
     * If NOW is outside any possible period, because the campaign hasn't started,
     * yet, or already ended, will return `undefined`.
     *
     * The first period is defined as `aggregationPeriodLength` number of days after
     * the `start` of the campaign.
     *
     * @returns {?{start: dayjs.Dayjs, end: dayjs.Dayjs}}
     */
    get currentMeasurementPeriod(): {
        start: dayjs.Dayjs;
        end: dayjs.Dayjs;
    } | null;
    /**
     * @returns {?{start: dayjs.Dayjs, end: dayjs.Dayjs}}
     */
    get nextTotalMeasurementPeriod(): {
        start: dayjs.Dayjs;
        end: dayjs.Dayjs;
    } | null;
    /**
     * Apply the `eventAggregationRule` to the given event with the given value.
     *
     * @param {Event} event
     *      The event to apply the value to.
     *
     * @param {number=} value
     *      The value to apply.
     */
    apply(event: Event, value?: number): void;
    toString(): string;
}
