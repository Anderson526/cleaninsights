/**
 * CleanInsights.ts
 * CleanInsightsSDK
 *
 * Created by Benjamin Erhart on 19.01.21.
 * Copyright Â© 2021 Guardian Project. All rights reserved.
 */
export { CleanInsights };
import { Campaign } from './Campaign';
import { CampaignConsent, ConsentState, Feature, FeatureConsent } from './consents';
import { Configuration, ConfigurationData } from './Configuration';
import { ConsentRequestUi } from './ConsentRequestUi';
import { Store } from './Store';
declare class CleanInsights {
    readonly conf: Configuration;
    private readonly store;
    private persistenceCounter;
    private sending;
    private failedSubmissionCount;
    private lastFailedSubmission;
    /**
     * @param {Object|Configuration} configuration
     *      The Configuration provided as a `Configuration` object or as a plain dictionary.
     *
     * @param {Store=} store=BrowserStore
     *      Either your own implementation of a `Store`. OPTIONAL.
     *      Defaults to `BrowserStore` which uses store-js - an abstraction over LocalStorage.
     */
    constructor(configuration: Configuration | ConfigurationData, store?: Store | string);
    /**
     * Track a scene visit.
     *
     * @param {string[]} scenePath: A hierarchical path best describing the structure of your scenes. E.g. `['Main', 'Settings', 'Some Setting']`.
     * @param {string} campaignId: The campaign ID as per your configuration, where this measurement belongs to.
     */
    measureVisit(scenePath: string[], campaignId: string): void;
    /**
     * Track an event.
     *
     * @param {string} category: The event category. Must not be empty. (eg. Videos, Music, Games...)
     * @param {string} action: The event action. Must not be empty. (eg. Play, Pause, Duration, Add Playlist, Downloaded, Clicked...)
     * @param {string} campaignId: The campaign ID as per your configuration, where this measurement belongs to.
     * @param {string=} name: The event name. OPTIONAL.
     * @param {number=} value: The event value. OPTIONAL.
     */
    measureEvent(category: string, action: string, campaignId: string, name?: string, value?: number): void;
    get featureConsents(): string[];
    get campaignConsents(): string[];
    getFeatureConsentByIndex(index: number): FeatureConsent | null;
    getCampaignConsentByIndex(index: number): CampaignConsent | null;
    grantFeature(feature: Feature): FeatureConsent;
    denyFeature(feature: Feature): FeatureConsent;
    /**
     * Returns the consent for a given feature, if any available.
     *
     * @param {Feature} feature The feature to get the consent for.
     * @returns {?FeatureConsent} the `FeatureConsent` for the given feature or `null`, if consent unknown.
     */
    consentForFeature(feature: Feature): FeatureConsent | null;
    /**
     * Checks the consent state of a feature.
     *
     * @param {Feature} feature The feature to check the consent state of.
     * @returns {ConsentState} the current state of consent.
     */
    stateOfFeature(feature: Feature): ConsentState;
    grantCampaign(campaignId: string): CampaignConsent | null;
    denyCampaign(campaignId: string): CampaignConsent | null;
    isCampaignCurrentlyGranted(campaignId: string): boolean;
    /**
     * Returns the consent for a given campaign, if any available.
     *
     * @param {string} campaignId The campaign ID to get the consent for.
     * @return {?CampaignConsent} the `CampaignConsent` for the given campaign or `null`, if consent unknown.
     */
    consentForCampaign(campaignId: string): CampaignConsent | null;
    /**
     * Checks the consent state of a campaign.
     *
     * @param {string} campaignId The campaign ID to check the consent state of.
     * @return {ConsentState} the current state of consent.
     */
    stateOfCampaign(campaignId: string): ConsentState;
    requestConsentForCampaign(campaignId: string, consentRequestUi: ConsentRequestUi, completed?: (granted: boolean) => void): string;
    requestConsentForFeature(feature: Feature, consentRequestUi: ConsentRequestUi, completed?: (granted: boolean) => void): string;
    /**
     * Sends an empty body to the server for easy debugging of server-related issues like TLS and CORS problems.
     *
     * **DON'T LEAVE THIS IN PRODUCTION**, once you're done fixing any server issues. There's absolutely no point in
     * pinging the server with this all the time and it will undermine your privacy promise to your users!
     *
     * @param {function(?Error)} done
     *      Callback, when the operation is finished, either successfully or not.
     */
    testServer(done?: (error?: Error) => void): void;
    /**
     * Persist accumulated data to the filesystem/local storage.
     *
     * A website should call this in an `onUnload` event, a Node.JS app should call this when the
     * process exits for whatever reason. (See [node-cleanup](https://github.com/jtlapp/node-cleanup)).
     */
    persist(): void;
    /**
     * Persist accumulated data to the filesystem/local storage.
     *
     * @param {boolean} async
     *      If true, returns immediately and does persistence asynchronously, only if it's already due.
     *
     * @param {boolean=} force=false
     *      Write regardless of threshold reached.
     */
    private _persist;
    private persistAndSend;
    getCampaignIfGood(campaignId: string, debugString: string): Campaign | null;
    /**
     * Get a `DataPoint` subclass out of the `haystack`, as long as it fits the `campaign`.
     * Increases `times` according to the campaigns rules.
     *
     * Create a new `DataPoint` if nothing is returned here.
     *
     * @param {DataPoint[]|Visit[]|Event[]} haystack:
     *      The haystack full of `DataPoint` subclasses.
     *
     * @param {string} campaignId:
     *      The campaign ID it must match.
     *
     * @param {Campaign} campaign:
     *      The campaign parameters to match against.
     *
     * @param {function(DataPoint):boolean} where:
     *      Additional condition for selection.
     *
     * @returns: {?(DataPoint|Visit|Event)} a `DataPoint` subclass out of the `haystack`, as long as it fits the `campaign`.
     */
    private getAndMeasure;
    private debug;
}
